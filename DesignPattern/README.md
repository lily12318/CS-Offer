# 设计模式

设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被理解、保证代码的可靠性。

**设计原则**：单一职责原则、开放封闭原则、依赖倒置原则、接口隔离原则和Liskov原则。

### 分类

创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式；

结构性模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式；

行为型模式：模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。

[以下摘抄至zky的总结]

#### 单例模式

有些对象我们只需要一个（像是线程池，缓冲，引擎的kernel等），这类对象只能有一个实例，一旦产生多个实例就会出现问题。所以，我们必须找到一种方法来确保我们的代码中只有一个实例——单例模式。

Hive中的单例有：CRenderEngine、CResourceExplorer等。

单例比全局变量的优势作用：

1. 保证对象只有一份，用户不能额外构造（构造函数是私有）。

2. 在需要使用时才会被创建，避免资源浪费，而全局变量在程序初始化时便被构造。

3. 提高程序可读性。

#### 桥接模式

桥接模式应用于有两个变化维度的系统。将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量，使得变化可以独立发生。

Hive中应用桥接模式的有：CRenderEngine、各种继承自IResource的类。通过桥接模式，引擎的抽象层CRenderEngine的功能实现可以与图形API分离，CRenderEngine实现某个功能时只需调用IRenderEngineImp中声明的接口即可（IRenderEngineImp*指针是CRenderEngine一个成员（组合复用）），而对于不同图形API的支持只需从IRenderEngineImp派生出OpenglEngine或DirectXEngine即可。抽象层功能的变化，或者是底层图形API的变化都不会对整体造成太大冲击。

桥接模式最明显的便是CTexture，抽象层根据需要需要派生处CInputTexture和CRenderTargetTexture，而底层实现又需要支持多种图形API，即存在两种变化。通过桥接模式，让这两种变化的耦合度降低，减少了维护成本。

#### 基于模板的工厂模式

将对象的创建和对象本身业务处理分离，降低了系统的耦合度，使得两者修改起来都相对容易。创建模板工厂类后，用户想生产新的Product，将具体Product类作为模板传入模板工厂类，即可生成具体工厂类，不必通过派生来生成具体工厂类。不过，为了实现对各种Product统一初始化，具体Product类还是要派生自CBaseProduct类。

Hive底层的类工厂（hiveOO中的工厂）就使用了该设计模式，此外为了建立字符串和具体工厂类之间的联系，还存在一个CFactoryData用来储存字符串和具体工厂对象指针的映射关系，通过字符串就可以定位到具体的工厂类对象，进而根据需要创建相应的资源。这种工厂在Hive中的作用：（1）让引擎可以根据配置文件去初始化不同的图形API层（根据API版本的关键字去搜索工厂，并获取对应工厂然后创建相应的对象，或GL或DX等）。（2）让引擎在配置渲染管线时可以根据配置文件中注册的ID找到用户自定义的RenderComponent类对象，并执行。

#### 抽象工厂

首先创建工厂基类（抽象工厂），然后派生出不同的工厂类（具体工厂）来生产不同的Product。为了实现对各种Product统一初始化，具体Product类还是要派生自CBaseProduct类。

Hive中抽象工厂的应用场景主要是资源管理方面，IResourceManager是抽象工厂，IResource是抽象产品。具体派生出各种工厂(CTextureManager、CRenderPassManager等)和产品(CTexture、CRenderPass)。通过工厂创建资源，可以实现资源统一初始化（由配置文件初始化），统一销毁（可配置，也可不统一销毁）。统一管理资源对大场景渲染尤其重要，当内存无法一次性放下整个场景的资源时，只有统一管理资源才能有效实现动态加载资源。

#### 代理模式

代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用。

Hive中的代理模式主要用在RenderPass上，对于引擎来说最好不要让用户跳过引擎直接用图形API来改变渲染管线状态，这将带来不稳定因素，因为当客户修改了图形API的管线状态后引擎往往并不能察觉，一旦客户在随后的代码中忘记了恢复原来的管线状态，那么引擎若再继续按以前未修改的管线状态执行随后的渲染，那么结果将是不可控的，而且这种不可控带来的问题非常不好调试（很难弄清是用户的bug还是引擎的bug）。

在实现中，Hive的抽象层的RenderPass储存了实际Pass的代理对象PassProxy，用户只能获得抽象层的RenderPass，用户对Pass的操作经过处理后只是暂存在RenderPass的PassProxy中，而并不会直接影响图形管线。渲染每一帧时，当用户对Pass的修改（通过RenderPass），处理并记录（记录在PassProxy中）完成后，所有的PassProxy将会被提交给实际的渲染管线执行渲染。这样可以让引擎对图形管线状态保持绝对控制，避免因用户错误操作而引起错误。

#### 观察者模式

在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。

Hive中的键盘响应就用了观察者模式，客户编写handleKeyboard函数，然后注册给引擎，当按键状态发生改变时，引擎便会调用注册的handleKeyboard函数来通知客户。



---

详见老张培训PPT or  [Elay's blog](http://popperelay.cn/categories/设计模式/)

