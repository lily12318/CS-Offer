# 操作系统基础

操作系统有四个特征：并发，共享，异步，虚拟。

操作系统的功能：处理器管理，存储器管理，文件管理，设备管理。

操作系统发展：单批道处理系统，多批道处理系统，分时系统，实时系统，网络与分布式系统和多机系统等。

### 进程管理

**进程**：计算机中已运行程序的实体。程序是指令的集合，进程是程序(指令集合)的真正运行。

- 进程与程序的区别：1）进程是一次运行活动，动态概念，后者是静态概念；2）前者具有生命周期，后者永久存在，可长期保存；3）进程和程序是多对多关系，但进程可以创建进程，而程序不能再形成新的程序；4）组成不同，进程包含程序、数据和进程控制块(PCB)，程序是一组有序的指令集合。
- 进程的状态：运行，就绪，阻塞，创建，结束。创建即还未就绪，结束指进咸亨正在从系统中消失。就绪是除了处理器资其他资源都已获取的状态，阻塞又称为等待状态，即等待出处理器外的其他资源或者等待某事件。

![进程三态状态转换图](L:\0 文档补充\06秋招\CS-Offer\Image\OS\进程三态状态转换图.png)

- 创建新进程会创建新的地址空间：子进程是父进程的复制品，在fork之后获得父进程的数据空间、堆和栈，而线程使用的是当前的地址空间。

**线程**：程序执行流的最小单元，由线程ID，当前指令指针(PC)，寄存器集合和堆栈组成。线程是进程中的一个实体，是被系统独立调度和分派的基本单位，自己不拥有系统资源(只拥有一点运行中必不可少的资源)，但可与同属同一个进程的线程共享进程所拥有的资源。也有就绪、阻塞和运行三种状态。

- 引入线程后，进程内涵变为，只作为除CPU以外系统资源的分配单元，而线程作为处理器的分配单元。
- 线程与进程的区别：1）调度方式：传统的操作系统中，拥有资源和独立调度的单位都是进程，但引入线程后，线程是独立调度的基本单位，进程是拥有资源的基本单位；2）拥有资源：进程拥有资源，线程不拥有资源(除一点必不可少的资源)但可共享隶属进程的系统资源；3）并发性：都可以并发执行，提高系统吞吐量；4）系统开销：由于进程和线程保存的资源不一样，导致进程创建和撤销时开销远大于线程创建撤销开销；5）地址空间和其他资源：进程的地址空间相互独立，统一进程的线程间共享进程的资源；6）通信方面：进程间通信需要借助操作系统，而线程间可以直接读/写进程数据段(如全局变量)来进行通信。

**进程通信与进程同步**

- 目的：1）数据传输；2）共享数据；3）通知事件；4）资源共享；5）进程控制。
- Linux下进程通信主要手段：1）管道(Pipe)及有名管道(named pipe)；2）信号(Signal)；3）消息队列(Message)：克服信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点；4）共享内存；5）信号量(semaphore)；6）套接口(Socket)。另，线程间通信：互斥量(Mutex)、信号量(Semaphore)、事件(Event)(Windows下)、临界区(Critical Section)(Windows下)。临界区只能用来同步本进程内的线程，是非内核对象，只有在用户态进行锁操作，速度快。

**调度算法**

- 典型算法：先来先服务算法(FCFS)、短作业优先算法(SJF)、优先级调度算法、高响应比优先调度算法、时间片轮转算法、多级反馈队列调度算法。SJF的平均等待时间，平均周转时间最少。

- 调度基本准则：

  1）CPU利用率；

  2）系统吞吐量 = 单位时间内CPU完成作业的数量；

  3）周转时间 = 作业完成时刻-作业到达时刻；

  4）等待时间 = 进程处于等处理器状态的时间之和；

  5）响应时间 = 用户提交请求到系统首次产生响应所用时间。

**死锁**：多个进程因竞争资源造成的一种僵局（相互等待），而进程无法推进。

- 原因：1）系统资源的竞争；2）进程推进顺序非法	

- 产生的必要条件：

  1）互斥条件：分配的资源仅为一个进程所占有，此时若有其他进程请求该资源，只能等待；

  2）不剥夺条件：进程的资源只能自己释放，不能被其他进程强行夺走；

  3）请求和保持条件:又称为部分分配条件。进程在等待新资源的同时，进程继续占有已分配到的资源。

  4）循环等待条件：存在一种进程资源的循环等待链，每个进程已有的资源同时被链中下一个进程锁请求。

- 死锁处理策略：

  1）预防死锁：即做一些限制，破坏四个必要条件中的一个；

  2）避免死锁：资源动态分配中，用某种方法防止系统进入不安全状态。如银行家算法；

  3）死锁的检测及解除：利用检测机制（如资源分配图）检测，利用以下方式解除：资源剥夺法；撤销进程法；进程回退法。

### 内存管理

操作系统对内存的划分和动态分配，就是内存管理。其功能包括：1）内存空间的分配与回收；2）地址转换；3）内存空间的扩充；4）存储保护。

地址重定位：将逻辑地址转换成物理地址。

内存管理分配方式：

- 内存管理分配方式→连续分配管理方式 && 非连续分配管理方式
- 非连续分配管理方式→（分区大小是否固定？）→分页存储管理方式 && 分段存储管理方式
- 分页存储管理方式→（运行作业时是否要把作业的所有页面都装入内存才能运行？）→基本分页存储管理方式 && 请求分页存储管理方式

**基本分页存储管理方式**：由于固定分区会产生内部碎片，动态分区会产生外部碎片，于是引入分页的思想，即把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。进程以块为单位申请主存中的空间。这样虽然也会产生内存碎片，但相对来说很小。

- 页面和页面大小：进程中的块称为页，内存中的块称为页框（页帧），外存中的块称为块；页面大小实际由页面偏移量的位数决定；

- 地址结构，逻辑结构如下：

  ![页地址结构](L:\0 文档补充\06秋招\CS-Offer\Image\OS\页地址结构.png)

- 页表：系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，一般存于内存中。作用是实现从页号到物理块号的地址映射，以便在内存中找到进程的每个页面所对应的物理块。

**基本分段存储管理方式**：按照用户进程中的自然段划分逻辑空间。段内要求连续，段间不要求连续。

- 逻辑地址结构如下：![段地址结构](L:\0 文档补充\06秋招\CS-Offer\Image\OS\段地址结构.png)

**段页式管理方式**：页式存储管理能有效的提高内存利用率，段式存储管理能反映程序的逻辑结构并有利于段的共享。段页式即将两种结合。

- 逻辑地址分为三部分：段号、页号和页内偏移量。
- 地址变换前提：系统为每个进程建立一张段表（包括段号、页表长度和页表起始地址），每个分段有一张页表（包括页号和块号）。
- 地址变换过程：首先通过段表查到页表起始地址，然后通过页表找到页帧号，最后形成物理地址。

**虚拟内存管理**：以上的内存管理策略特点是将作业一次性全部装入内存后运行，程序运行中不用或者暂时不用的程序(数据)占据了大量内存空间，浪费内存资源。因此利用虚拟内存管理方式，包括虚拟存储器和请求分页\分段\段页管理方式两部分。

- 虚拟存储器：程序执行过程中，将需要的部分调入内存，不需要的换出到外存，从而腾出更多的空间存放将要调入内存的信息。这样，系统好像提供了一个比实际内存大得多的存储器，称为虚拟存储器。
- 请求分\分段\段页存储管理需要一定支持：1）一定容量的内外存；2）页表机制\段表机制；3）中断机构；4）地址变换机构。

**请求分页管理方式**：基于基本分页系统基础，增加请求调页功能和页面置换功能。常见算法如下：

- 最佳置换算法：选择被淘汰的页面式以后永不使用，或者式最长时间内不再被访问的页面，这样可保证获得最低的缺页率；

- 先进先出（FIFO）页面置换算法：优先淘汰最早进入内存的页面。可能发生Belady异常，即当分配的物理块数增大，页缺页率不减反增的异常现象；

- 最近最久未使用（LRU）置换算法：选择最近最长时间未访问过的页面予以淘汰。

  最佳置换算法是”向后看“，LRU是”向前看“的。

  抖动：刚刚换出的页面马上又要换入主存，或刚刚换入的页面马上又要换出主存，这样频繁的页面调度行为。主要原因是：某进程频繁访问的页面数目高于可用的物理页帧数目。

  工作集：指在某段时间间隔内，进程要访问的页面集合。根据工作集，为进程分配大于工作机的物理块，能防止抖动，且提高存储器的利用率和系统吞吐量。

### Linux常用命令

#### 目录和文件操作

**目录**：

![Linux目录](L:\0 文档补充\06秋招\CS-Offer\Image\OS\Linux目录.png)

**操作**：

- **cd** /home        cd(Change Direction)，用来变换工作目录

- **pwd**        Print Working Direction，显示目前所在目录

- **mkdir**        Make Direction，建立新目录

  mkdir -p /home/bird/testing/test1，当中间层级没有时，这里的-p可自动将各层级的目录建立

- **rmdir**        Remove Direction，删除某目录

  删除也需要一层一层删除，且只能删除空目录（即不包含任何文件或目录）。如果要删除非空目录，则用如 rm -r test

- **ls**        List，文件与目录的查看。最常用的选项是”-l“

- **cp**        Copy，复制文件或目录

  cp  ./aaa  /tmp/bbb，表示将当前目录下的aaa文件复制到/tmp下，并更名为bbb

  cp  -r  /etc/  /tmp，复制目录/etc/下的所有内容到/tmp下，复制目录需使用”-r“选项

- **rm**        Remove，删除文件或目录，若删除目录必加上”-r“，否则只会删除文件

- **mv**        Move，移动或更名现有的文件或目录

  mv  /home/test  /home/test2，更改一个目录的名称

#### 文本文件内容查看

- **cat**      Concatenate(连续)，将一个文件的内容连续输出到屏幕上

  cat  ./aaa，显示当前目录下aaa的内容

- **tac**        将文件内容从最后一行到第一行反向显示到屏幕上

- **nl**        Number of Lines，显示文件内容的时候，一起显示文件行号

- **more**        一页一页显示文件内容，防止nl,cat,tac一次性数据显示行数太多，前面内容查看不了的情况

- **less**        与more类似，但可以向前翻页

- **head**        该命令查看文本文件时，只显示头几行

  head  -n  number  文件名，表示值显示文件的前number行

  head  -n  -100  /etc/man.config，这里Number为负数，表示打印前面的所有行除开最后的|number|行，这里如果文件又141行，则表示只打印前面的41行

- **tail**       只显示尾几行

  tail  -n  number 文件名。  当”number“前面有”+“时，与 head  -n  -xx 有异曲同工之妙

  tail  -n  +100  /etc/man.config， 代表文件从100行以后会被列出来，前面99行不会被显示

- **touch**        建立一个空文件

  touch  aaa

- **grep**        Global Regular Expression Print，分析一行信息，若当中有我们所需要的信息，久将该行显示出来

  cat  aaa  |  grep  "root"，将文件aaa中包含”root“的行的内容显示出来， 或者grep  "root"  aaa

  ”grep -E“表示后面跟着的内容是延伸型正则表达式，等价于”egrep“

#### 查看系统信息

- **df**        Disk Free，列出文件系统的整体磁盘使用量

- **ps**        Process Status，将某个时间点的程序运行情况显示出来

- **top**        动态持续侦侦测程序运作的状态

  